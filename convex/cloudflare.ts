/**
 * @created 2025-08-25
 * 
 * -- Cloudflare Image API -- 
 * @function generateImageDirectUploadURL
 * @description This function is used to generate a upload URL for a single image.
 * @param {string} filename - the name of the image file will be added to the metadata.
 * @param {string} token - the token generated by the generateBatchToken function.
 * @returns {ImageUploadURLResponse} - An object containing the upload URL, success status, errors, and messages. The upload URL
 * is valid for our set expiry (2 minutes). This url is used to upload the image to Cloudflare. We can run this function for as long
 * as the token is valid without exceeding the rate limit.
 * 
 * @summary 
 * Uploading
 * 1. Request a one-time upload URL with response containing id and uploadURL.
 * 2. POST request to uploadURL with the image blob as the body.
 *    a. After calling the endpoint, a new draft image record is created while it waits for the image to be uploaded.
 *       You can check the status of the image upload by calling the direct_upload endpoint with the one-time uploadURL.
 * 3. Save the image ID and uploadURL to the database document.
 * 
 * Serving
 * 1. Use the Image ID to construct a delivery URL: `{uploadURL}/mobile`
 */


import { v } from "convex/values";
import crypto from 'crypto';
import { action } from "./_generated/server";

const API_TOKEN = process.env.CLOUDFLARE_API_TOKEN;
const BASE_URL = `https://api.cloudflare.com/client/v4/accounts/${process.env.CLOUDFLARE_ACCOUNT_ID}/images`;

export const generateImageUploadURL = action({
    args: {
        filename: v.string(),
    }, handler: async (ctx, { filename }) => {
        const url = `${BASE_URL}/v2/direct_upload`;

        const form = new FormData();
        // form.append('expiry', new Date(Date.now() + 1000 * 60 * 2).toISOString());
        form.append('requireSignedURLs', 'true');
        form.append('metadata', JSON.stringify({ filename }));

        console.log("Form: ", form);

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${API_TOKEN}`,
            },
            body: form,
        });

        if (!response.ok) {
            const text = await response.text();
            console.error("Response Text: ", text);
            throw new Error("UploadURL Gen Failed: " + response.status + response.statusText);
        }

        const data = await response.json();
        console.log("Response: ", data);

        return data;
    },
});

export const generateSignedURL = action({
    args: {
        identifier: v.string(), // image_id
        variant: v.optional(v.string()), // variant name
    }, handler: async (ctx, { identifier, variant }) => {
        const sigKey = process.env.CLOUDFLARE_IMAGE_SIG_TOKEN;
        const accountHash = process.env.CLOUDFLARE_ACCOUNT_HASH;

        const expiry = Math.floor(Date.now() / 1000) + 60 * 60 * 24;

        const path = variant
            ? `/${accountHash}/${identifier}/${variant}?exp=${expiry}`
            : `/${accountHash}/${identifier}?exp=${expiry}`;

        const sig = crypto.createHmac('sha256', sigKey).update(path).digest('hex');

        return `https://imagedelivery.net${path}&sig=${sig}`;
    }
});

// export const generateSignedURL = action({
//     args: {
//         identifier: v.string(),
//         variant: v.string(),
//     }, handler: async (ctx, { identifier, variant }) => {
//         const baseUrl = `https://imagedelivery.net/dfEBx1P7mYwRwFqkE9QiQA/${identifier}/${variant}`;
//         const url = new URL(baseUrl);

//         const encoder = new TextEncoder();
//         const secretKeyData = encoder.encode(process.env.CLOUDFLARE_IMAGE_SIG_TOKEN);
//         const key = await crypto.subtle.importKey(
//             "raw",
//             secretKeyData,
//             { name: 'HMAC', hash: 'SHA-256' },
//             false,
//             ['sign'],
//         );

//         const expiry = Math.floor(Date.now() / 1000) + 60 * 60 * 24; // 24 hours
//         url.searchParams.set('exp', expiry.toString());
//         // url now looks like: https://imagedelivery.net/cheeW4oKsx5ljh8e8BoL2A/bc27a117-9509-446b-8c69-c81bfeac0a01/public?exp=1631289275

//         const stringToSign = url.pathname + '?' + url.searchParams.toString();
//         // we need to sign the pathname and search params together.
//         // for example, /cheeW4oKsx5ljh8e8BoL2A/bc27a117-9509-446b-8c69-c81bfeac0a01/mobile?exp=1631289275

//         // generate the signature
//         const mac = await crypto.subtle.sign('HMAC', key, encoder.encode(stringToSign));
//         const sig = bufferToHex(new Uint8Array(mac).buffer);

//         // attatch it to the `url`
//         url.searchParams.set('sig', sig);
//         return new Response(url.toString());
//     }
// });



// interface VideoUploadURLResponse {
//     uid: string;
//     uploadURL: string;
//     success: boolean;
//     errors: string[];
//     messages: string[];
// }

// export const getVideoUploadURL = mutation({
//     args: {
//         filename: v.string(),
//     }, handler: async (ctx, { filename }): Promise<VideoUploadURLResponse> => {
//         const identity = await ctx.auth.getUserIdentity();
//         if (!identity) throw new Error("Unauthorized");

//         const url = `https://api.cloudflare.com/client/v4/accounts/${process.env.CLOUDFLARE_ACCOUNT_ID}/stream/direct_upload`;

//         const payload = {
//             maxDurationSeconds: 60,
//             requireSignedURLs: true,
//             expiry: new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString(),
//             meta: {
//                 name: filename
//             }
//         }

//         const response = await fetch(url, {
//             method: 'POST',
//             headers: {
//                 'Authorization': `Bearer ${process.env.CLOUDFLARE_API_TOKEN}`,
//             },
//             body: JSON.stringify(payload),
//         });

//         if (!response.ok) throw new Error("Failed to generate upload URL");

//         const { result: { uid, uploadURL }, success, errors, messages } = await response.json();

//         return { uid, uploadURL, success, errors, messages };
//     }
// });

// export const uploadVideo = mutation({
//     args: {
//         uploadURL: v.string(),
//     }, handler: async (ctx, { uploadURL }) => {
//         const identity = await ctx.auth.getUserIdentity();
//         if (!identity) throw new Error("Unauthorized");

//         const response = await fetch(uploadURL, {
//             method: 'POST',
//             headers: {

//             }
//         });
//     }
// })