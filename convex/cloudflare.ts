"use node";

/**
 * @created 2025-08-25
 * 
 * -- Cloudflare Image API -- 
 * @function generateImageDirectUploadURL
 * @description This function is used to generate a upload URL for a single image.
 * @param {string} filename - the name of the image file will be added to the metadata.
 * @param {string} token - the token generated by the generateBatchToken function.
 * @returns {ImageUploadURLResponse} - An object containing the upload URL, success status, errors, and messages. The upload URL
 * is valid for our set expiry (2 minutes). This url is used to upload the image to Cloudflare. We can run this function for as long
 * as the token is valid without exceeding the rate limit.
 * 
 * @summary 
 * Uploading
 * 1. Request a one-time upload URL with response containing id and uploadURL.
 * 2. POST request to uploadURL with the image blob as the body.
 *    a. After calling the endpoint, a new draft image record is created while it waits for the image to be uploaded.
 *       You can check the status of the image upload by calling the direct_upload endpoint with the one-time uploadURL.
 * 3. Save the image ID and uploadURL to the database document.
 * 
 * Serving
 * 1. Use the Image ID to construct a delivery URL: `{uploadURL}/mobile`
 */

import { v } from "convex/values";
import crypto from 'crypto';
import { action } from "./_generated/server";

const API_TOKEN = process.env.CLOUDFLARE_API_TOKEN;
const BASE_URL = `https://api.cloudflare.com/client/v4/accounts/${process.env.CLOUDFLARE_ACCOUNT_ID}`;
const STREAM_BASE_URL = ``

export const generateImageUploadURL = action({
    args: {
        filename: v.string(),
    }, handler: async (ctx, { filename }) => {
        const url = `${BASE_URL}/images/v2/direct_upload`;

        const form = new FormData();
        // form.append('expiry', new Date(Date.now() + 1000 * 60 * 2).toISOString());
        form.append('requireSignedURLs', 'true');
        form.append('metadata', JSON.stringify({ filename }));

        console.log("Form: ", form);

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${API_TOKEN}`,
            },
            body: form,
        });

        if (!response.ok) {
            const text = await response.text();
            console.error("Response Text: ", text);
            throw new Error("UploadURL Gen Failed: " + response.status + response.statusText);
        }

        const data = await response.json();
        console.log("Response: ", data);

        return data;
    },
});

export const generateSignedImageURL = action({
    args: {
        identifier: v.string(), // image_id
        variant: v.optional(v.string()), // variant name
    }, handler: async (ctx, { identifier, variant }) => {
        const sigKey = process.env.CLOUDFLARE_IMAGE_SIG_TOKEN;
        const accountHash = process.env.CLOUDFLARE_ACCOUNT_HASH;

        const expiry = Math.floor(Date.now() / 1000) + 60 * 60 * 24;

        const path = variant
            ? `/${accountHash}/${identifier}/${variant}?exp=${expiry}`
            : `/${accountHash}/${identifier}?exp=${expiry}`;

        const sig = crypto.createHmac('sha256', sigKey).update(path).digest('hex');

        return `https://imagedelivery.net${path}&sig=${sig}`;
    }
});


/**
 * @function generateVideoUploadURL
 * @description This function is used to generate a upload URL for a single video.
 * @returns uid: string; uploadURL: string;
 * 
 * @function generateVideoToken
 * @description This funciton is used to generate a signed token to stream a video.
 * @notes
 * 
 * We generated a signing key and stored the jwk and pem. I decoded the pem to get the private key and stored
 * in Convex env variables. I am using the pem over the jwk because the jwk is not supported by the node.js crypto library.
 * 
 * @returns {string} - The function returns the signed token so we can construct the full playback url client side. The reason
 * for this is because we'll want to specify the endpoint depending on the usecase (thumbnails, full video, etc).
 * 
 * For full playback, the format is https://customer-<customer_id>.cloudflarestream.com/<signed_token>/manifest/video.m3u8
 * For thumbnail, the format is https://customer-<customer_id>.cloudflarestream.com/<signed_token>/thumbnails/thumbnail.jpg
 * 
 */
export const generateVideoUploadURL = action({
    args: {
        filename: v.string(),
    }, handler: async (ctx, { filename }) => {
        const url = `${BASE_URL}/stream/direct_upload`;

        const form = new FormData();
        form.append('maxDurationSeconds', '60');
        form.append('requireSignedURLs', 'true');
        form.append('metadata', JSON.stringify({ filename }));

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${API_TOKEN}`,
            },
            body: form,
        });

        if (!response.ok) {
            const text = await response.text();
            console.error("Response Text: ", text);
            throw new Error("UploadURL Gen Failed: " + response.status + response.statusText);
        }

        const data = await response.json();
        console.log("Response: ", data);

        return data;
    }
});

export const generateVideoToken = action({
    args: {
        videoUID: v.string(),
    }, handler: async (ctx, { videoUID }) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) throw new Error('Unauthorized');

        const pem = process.env.CLOUDFLARE_STREAM_PEM;
        const keyID = process.env.CLOUDFLARE_STREAM_KEY_ID;
        const expiresIn = Math.floor(Date.now() / 1000) + 60 * 60 * 24 * 3; // 3 days

        const header = {
            alg: 'RS256',
            kid: keyID,
        };

        const payload = {
            sub: videoUID,
            kid: keyID,
            exp: expiresIn,
        };

        const encode = (obj: any) => {
            return Buffer.from(JSON.stringify(obj))
                .toString('base64')
                .replace(/=/g, "")
                .replace(/\+/g, "-")
                .replace(/\//g, "_");
        };

        const token = `${encode(header)}.${encode(payload)}`;

        const signer = crypto.createSign('RSA-SHA256');
        signer.update(token);
        signer.end();

        const signature = signer.sign(pem);
        const signatureB64 = signature.toString('base64')
            .replace(/=/g, "")
            .replace(/\+/g, "-")
            .replace(/\//g, "_");

        return `${token}.${signatureB64}`;
    }
});